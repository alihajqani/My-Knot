---
tags:
  - devops/docker
  - infrastructure/compose
  - best-practices
---

# Advanced Docker Compose Patterns

## üìå Concept & Analogy
**Definition:** Utilizing advanced YAML features and Docker metadata to create maintainable, efficient, and environment-agnostic orchestration files.
*   *Analogy:*
    *   **DRY/Anchors:** A "Rubber Stamp". Instead of hand-writing the same rules on every document, you make a stamp (Anchor) and press it everywhere (Alias).
    *   **Profiles:** A "Smart Home Panel". You don't turn on every light in the house at once; you have modes like "Movie Night" (frontend only) or "Cleaning" (all services).

## ‚öôÔ∏è Engineering Vision
A junior developer writes a 500-line `docker-compose.yml` with copy-pasted configuration. A senior engineer focuses on:
1.  **Maintainability (DRY):** Change logging settings in one place, update 10 services instantly.
2.  **Resource Efficiency (Profiles):** Developers shouldn't run a heavy Data Science container just to fix a UI bug.
3.  **Observability (Identity):** Searching logs for `api-server` is easier than `project_backend_1_73d8a`.
4.  **Security (Env Injection):** Credentials never live in git; they are injected at runtime.

## üíª Code & Implementation
Here is a "Master Configuration" demonstrating all 6 concepts in a single file.

### ‚ùå Junior Approach (Verbose & Rigid)
*   Lots of repetition.
*   Hardcoded secrets. 
*   Everything runs at once.

### ‚úÖ Senior Approach (The "Master" Compose)
Incorporating: **DRY, Profiles, Networking, Lifecycle, Envs, and Identity.**

```yaml
version: "3.9"

# 1. DRY: Define Reusable Blocks (Extension Fields)
# ------------------------------------------------
x-logging-config: &logging_anchor
  driver: "json-file"
  options:
    max-size: "10m"
    max-file: "3"

x-base-service: &service_base
  restart: always
  # Merge logic (<<:) applies logging config to this block
  logging: *logging_anchor
  # 5. Environment Injection (12-Factor App)
  env_file:
    - .env

services:
  # 4. Lifecycle: Daemon (Long-running Service)
  backend-api:
    <<: *service_base  # Inherit base config
    # 6. Identity: Explicit Container Name
    container_name: production-api-v1
    image: my-python-api:latest
    # 2. Orchestration: Profiles
    # Only runs if you type: docker-compose --profile backend up
    profiles: ["backend", "all"] 
    # 3. Networking: Port Mapping (Host:Container)
    ports:
      - "8000:8000"
    networks:
      - app_network

  # 4. Lifecycle: Ephemeral Task (One-off)
  db-migration:
    <<: *service_base
    container_name: migration-runner
    image: my-python-api:latest
    # Overwrite the command to run a task, then exit
    command: ["python", "manage.py", "migrate"]
    restart: "no" # Ephemeral: Do not restart after success
    depends_on:
      - database
    profiles: ["tools"]

  database:
    image: postgres:15
    container_name: main-postgres
    # 3. Networking: Host Mode (Performance)
    # ‚ö†Ô∏è Caution: Bypasses Docker network isolation. 
    # Useful for high-throughput, but dangerous for security.
    # network_mode: host 
    environment:
      POSTGRES_USER: ${DB_USER} # Injected from .env
      POSTGRES_PASSWORD: ${DB_PASS}
    networks:
      - app_network

networks:
  app_network:
    driver: bridge
```

## üí° Best Practices & Pitfalls

### 1. DRY & Configuration
*   ‚úÖ **Use Anchors (`&`)** for shared volume mounts, logging drivers, and environment files.
*   ‚ö†Ô∏è **Don't Over-Engineer:** If you only have 2 services, inheritance might add unnecessary complexity.

### 2. Networking
*   ‚úÖ **Use Bridge (Default):** For 99% of web apps. It keeps ports isolated and secure.
*   ‚ö†Ô∏è **Avoid Host Mode:** Unless you have a specific bottleneck (e.g., massive UDP traffic or high-frequency trading). It creates port conflicts on the host machine.

### 3. Profiles & Lifecycle
*   ‚úÖ **Use Profiles for Dev Experience:** Create a `debug` profile that runs services with verbose logging or attached debuggers.
*   ‚úÖ **Separate Ephemeral Tasks:** Don't make your API container run migrations on startup (common junior mistake). It slows down scaling. Use a separate `migration` service or an Init Container pattern.

### 4. Identity
*   ‚úÖ **Name Containers:** Use `container_name` to make `docker logs production-api-v1` possible.
*   ‚ö†Ô∏è **Naming Conflict:** If you run multiple instances of the same project (e.g., in CI/CD), hardcoded names will crash Docker. Use distinct project names in CI.